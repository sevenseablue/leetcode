class Solution:
    def knapsack(self, val, wt, n, W):
        dp = [0]*(W+1)
        for i in range(n):
            for j in range(W, wt[i]-1, -1):
                dp[j] = max(dp[j-wt[i]] + val[i], dp[j])

    def findMaxForm(self, strs, m, n):
        """
        :type strs: List[str]
        :type m: int
        :type n: int
        :rtype: int
        """
        # strs = sorted(map(lambda s: (s.count('0'), s.count('1')), strs), key=lambda x: (x[0] + x[1], x))
        dp = [[0 for i in range(n+1)] for j in range(m+1)]
        for k in range(len(strs)):
            numzeros = sum([1 for s in strs[k] if s == "0"])
            numones = len(strs[k]) - numzeros
            # numzeros, numones = strs[k]
            for i in range(m, numzeros - 1, -1):
                for j in range(n, numones - 1, -1):
                    dp[i][j] = max(dp[i][j], dp[i-numzeros][j-numones] + 1)
        return dp[m][n]

# class Solution(object):
#     def findMaxForm(self, strs, m, n):
#         """
#         :type strs: List[str]
#         :type m: int
#         :type n: int
#         :rtype: int
#         """
#         cache = {}
#         strs = sorted(map(lambda s:(s.count('0'),s.count('1')),strs),key=lambda x:(x[0]+x[1],x))
#         sn = len(strs)
#         def dfs(index, m, n):
#             if index == len(strs) or (m == 0 and n == 0):
#                 return 0
#             if (index, m, n) not in cache:
#                 res = 0
#                 for i in xrange(index, sn):
#                     if i > index and strs[i] == strs[i-1]:
#                         continue
#                     zero, one = strs[i]
#                     if m >= zero and n >= one:
#                         res = max(res, dfs(i+1, m-zero, n-one) + 1)
#                 cache[(index, m, n)] = res
#             return cache[(index, m, n)]
#         return dfs(0, m, n)

solu = Solution()
Array = ["10", "0001", "111001", "1", "0"]
m = 5
n = 3
Array = ["10", "0", "1"]
m = 1
n = 1
Array = ["1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101","1101","0101"]
m = 100
n = 100
import time
t1 = time.time()
print(solu.findMaxForm(Array, m, n))
print(time.time() - t1)

